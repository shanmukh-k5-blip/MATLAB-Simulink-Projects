component ModuleType1
    % ModuleType1:2
    % Module Block
    %    Model resolution: Detailed
    %    Number of parallel assemblies: 1
    %    Number of cells per parallel assembly: 14
    %
    %    MATLAB version: 25.2
    %    Simscape Battery version: 25.2
    %    Simscape code generated on: 16-Oct-2025 23:15:39

    parameters
        SOC_vecCell = {[0, .1, .25, .5, .75, .9, 1],'1'}; % Vector of state-of-charge values, SOC
        V0_vecCell = {[3.5057, 3.566, 3.6337, 3.7127, 3.9259, 4.0777, 4.1928],'V'}; % Open-circuit voltage, V0(SOC)
        V_rangeCell = {[3.507,4.1928],'V'}; % Terminal voltage operating range [Min Max]
        R0_vecCell = {[.0085, .0085, .0087, .0082, .0083, .0085, .0085],'Ohm'}; % Terminal resistance, R0(SOC)
        AHCell = {27,'A*hr'}; % Cell capacity, AH
        extrapolation_optionCell = {simscape.enum.extrapolation.nearest,'1'}; % Extrapolation method for all tables
    end

    parameters(ExternalAccess=none)
        P = 14; % Batteries in Parallel
        S = 1; % Batteries in Series
        CellCount = P*S; % Number of cells in battery
    end

    outputs
        socOutCell; % SOC
    end

    nodes
        p = foundation.electrical.electrical; % +
        n = foundation.electrical.electrical; % -
    end

    variables
        iCell = {repmat(0,14,1),'A'}; % Cell current (positive in)
        vCell = {repmat(0,14,1),'V'}; % Cell terminal voltage
        socCell = {value={repmat(1,14,1),'1'},priority=priority.high}; % Cell state of charge
        numCyclesCell = {value={repmat(0,14,1),'1'},priority=priority.high}; % Cell discharge cycles
        vParallelAssembly = {value={0,'V'},priority=priority.none}; % Parallel Assembly Voltage
        socParallelAssembly = {value={1,'1'},priority=priority.none}; % Parallel Assembly state of charge
    end

    equations
        assert(length(iCell) == CellCount);
        assert(length(vCell) == CellCount);
        assert(length(socCell) == CellCount);
        assert(length(numCyclesCell) == CellCount);
        assert(length(vParallelAssembly) == S);
        assert(length(socParallelAssembly) == S);
        socOutCell == [NCM_TP_parallel(:).socOutCell];
    end

    connections
        connect(p,NCM_TP_parallel(1).p);
        connect(n,NCM_TP_parallel(end).n);
    end

    annotations
        [p] : Side=top;
        [n] : Side=bottom;
        UILayout = [UIGroup("Main",SOC_vecCell,V0_vecCell,V_rangeCell,R0_vecCell,AHCell,extrapolation_optionCell)];
        Icon = 'module.svg';
    end

    for Sidx = 1:S
        components(ExternalAccess=observe,CompileReuse=true)
            NCM_TP_parallel(Sidx) = NCM_TP_3700W_Pack.ParallelAssemblies.ParallelAssemblyType1(...
                P = P,SOC_vecCell = SOC_vecCell,V0_vecCell = V0_vecCell,...
                V_rangeCell = V_rangeCell,R0_vecCell = R0_vecCell,AHCell = AHCell,...
                extrapolation_optionCell = extrapolation_optionCell,iCell.priority = priority.none,...
                vCell.priority = priority.none,socCell.priority = priority.none,...
                numCyclesCell.priority = priority.none,...
                vParallelAssembly.priority = priority.none,socParallelAssembly.priority = priority.none);
        end
    end

    for Sidx = 1:S-1
        connections
            connect(NCM_TP_parallel(Sidx).n,NCM_TP_parallel(Sidx+1).p);
        end
    end

    for Sidx = 1:S
        equations
            NCM_TP_parallel(Sidx).iCell == reshape(iCell((Sidx*P-(P-1)):(Sidx*P)),P,1);
            NCM_TP_parallel(Sidx).vCell == reshape(vCell((Sidx*P-(P-1)):(Sidx*P)),P,1);
            NCM_TP_parallel(Sidx).socCell == reshape(socCell((Sidx*P-(P-1)):(Sidx*P)),P,1);
            NCM_TP_parallel(Sidx).numCyclesCell == reshape(numCyclesCell((Sidx*P-(P-1)):(Sidx*P)),P,1);
            NCM_TP_parallel(Sidx).vParallelAssembly == vParallelAssembly(Sidx);
            NCM_TP_parallel(Sidx).socParallelAssembly == socParallelAssembly(Sidx);
        end
    end
end